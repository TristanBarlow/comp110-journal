## When does a Physical system compute?[1]##
  
From my understanding every time we type a line of code its considered to be an abstract theory, the computer then encodes the theory into a physical representation the of what we have scripted it then proceeds to turn this physical representation into an abstract output for example the answer to a maths problem. Another important concept brought up is the ‘representation relation’ It is described in the paper to cross ‘the divide between the abstract and the physical’ does that mean it is the process by which an input (a line of code) to something physical that can then go through computation? Is it even a process?

One point I was a bit confused on was the idea of encoded communication (the example being hieroglyphics). I believe the idea was once we knew how to decode the physical communication we do a computation turning the abstract ‘code’ or the hieroglyphic into a form we can understand and then back into the abstract output, the message. In this case although not stated, do they mean we are the computer. 
 (Question: in a conventional computer are all computations done physically, is there a physical process occurring by the computer to achieve the desired output? If so what is this physical process?).

## Experimental Investigations of the Utility of Detailed Flowcharts in Programming. [2] ##

This paper for the most part is the compiling of several experiments where programming students are split into groups, some are given flowcharts (sometimes of differing complexity) others are not. They are then told to complete an exercise to do with programming and the results are then compared. The results are all the same; there is no difference between the subjects who used the flowcharts and those who didn’t.  As a result of my own experiences I am not surprised. The process of learning to become a programmer teaches you to think like a flowchart. When being taught how to evaluated code we were taught using the aid of a few flowcharts. I believe that a flow chart isn’t a tool to use but more of a structure on how you should think through each programming problem. Giving a group of programmers a diagram describing the process their brain would work without the flowchart will of course produce no measurable result. If for example you gave a flowchart to a group of non-programmers and created similar experiments using pseudocode they could understand the results may be very different.


## A Fast Procedure for Computing the Distance Between Complex Objects in Three-Dimensional Space[3] ##


## Go To Statement Considered Harmful [4] #
From my limited understating a ‘go to’ statement performs a one-way movement of what line the machine will execute. The Author starts by making the observation that “the quality of programmers is a decreasing function of the density of go to statements in the program they produce.” After finishing the paper, I believe the main concern the author has about the go to statement, is the inability of the observers to determine the state of the process (variable values etc.) at any given instances of the process. This will result in it being ‘terribly hard to find a meaningful set of variables’ and us losing our intellectual grasp of the procedure. The possible implications to industry practice? For example, you have to fix a bug, not being able to track the value of the variables causing the bug will be a serious barrier to overcoming said bug. If my understanding of the damage is correct, this may be somewhat mitigated by tools such as the debugger found in ‘Pycharm’ IDE. However, because python has no ‘go to’ statements I haven’t tested. This makes me question; could exit, while and repeats statements be  harmful?

## Reference list ##
[1] Horsman C, Stepney S, Wagner RC, Kendon V. 2014 When does a physical system compute?,Proc. R. Soc. A 470:20140182. http://dx.doi.org/10.1098/rspa.2014.0182
[2] B. Shneiderman, R. Mayer, D. McKay and P. Heller, Experimental Investigations of the Utility of Detailed Flowcharts in Programming, Communications of the ACM, Volume 20, Issue 6, June 1977, pp. 373 - 381
[3]Elmer G. Gilbert, Fellow, IEEE, Daniel W. Johnson, and S. Saythiya Keerth, IEEE journal of robotics and automation, vol. 4, no.2 April 1988


http://delivery.acm.org.ezproxy.falmouth.ac.uk/10.1145/370000/362337/p503-peterson.pdf?ip=193.61.64.8&id=362337&acc=ACTIVE%20SERVICE&key=BF07A2EE685417C5%2EEAA225A8AB01C582%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&CFID=864725705&CFTOKEN=40670159&__acm__=1479126150_9e9344fb8d56f93789c5ee69b09e6594
